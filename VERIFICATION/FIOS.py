

# This file was *autogenerated* from the file FIOS.sage
from sage.all_cmdline import *   # import sage library

_sage_const_17 = Integer(17); _sage_const_256 = Integer(256); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_512 = Integer(512)
import math
import random

def FIOS(n, a, b, w = _sage_const_17 , WIDTH = _sage_const_256 ):

	# WIDTH is taken to be the width of n and the operands plus 2
	# in order for intermediate results to be contained without
	# having to perform the final subtraction of the Montgomery Multiplication
	WIDTH = WIDTH + _sage_const_2 
	
	# s is the number of blocks of width w required to slice operands
	s = (WIDTH-_sage_const_1 )//w + _sage_const_1 
	
	W = _sage_const_2 **w
	
	R = _sage_const_2 **(s*w)
	R_inv = inverse_mod(R, n)
	
	n_prime_0 = inverse_mod(-n, R) % W
	
	a_arr = [(a >> (i*w)) % W for i in range(s)]
	b_arr = [(b >> (i*w)) % W for i in range(s)]
	n_arr = [(n >> (i*w)) % W for i in range(s)]
	
	res_arr = s*[_sage_const_0 ]
	
	for i in range(s):
		
		# The outer loop scans the a operand.
		# the least significant block of the result is processed
		# and reduced at the beginning of each iterations
		
		res_arr[_sage_const_0 ] += a_arr[i]*b_arr[_sage_const_0 ]
		
		m = res_arr[_sage_const_0 ]*n_prime_0 % W
		
		res_arr[_sage_const_0 ] += m*n_arr[_sage_const_0 ]
		res_arr[_sage_const_0 ] = res_arr[_sage_const_0 ] >> w
		
		for j in range(_sage_const_1 , s):
		
			# The inner loop scans the b operand.
			# The remaining blocks are processed in this loop.
		
			res_arr[j-_sage_const_1 ] += a_arr[i]*b_arr[j] + m*n_arr[j] + res_arr[j]
			
			res_arr[j] = res_arr[j-_sage_const_1 ] >> w
			res_arr[j-_sage_const_1 ] = res_arr[j-_sage_const_1 ] % W
			
	
	return res_arr, n_prime_0
	
	
if __name__ == "__main__":

	# Running this file will test one random set of inputs fed to the FIOS function

	WIDTH = _sage_const_256 

	n = random_prime(_sage_const_2 **WIDTH, False, _sage_const_2 **(WIDTH-_sage_const_1 ))
	
	print("WIDTH : ", WIDTH)
	
	a = random.randrange(_sage_const_2 **(WIDTH-_sage_const_1 ), n)
	b = random.randrange(_sage_const_2 **(WIDTH-_sage_const_1 ), n)
	

	WIDTH = WIDTH + _sage_const_2 

	w = _sage_const_17 
	
	s = (WIDTH-_sage_const_1 )//w + _sage_const_1 

	R = _sage_const_2 **(s*w)
	R_inv = inverse_mod(R, n)
	

	verif = a*b*R_inv % n

	res_arr = FIOS(n, a, b, w, WIDTH = WIDTH )[_sage_const_0 ]

	res = _sage_const_0 
	for i in range(len(res_arr)):
	
		res += res_arr[i] << (i*w)
		
	print("n : ", hex(n), "\na : ", hex(a), "\nb : ", hex(b))
	
	print("\ntest  : ", hex(res), "\nverif : ", hex(verif), "\nmatch : ", res == verif)

